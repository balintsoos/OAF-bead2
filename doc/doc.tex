\documentclass[a4paper,12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin2]{inputenc}
\usepackage[magyar]{babel}

% használt betûtípusok  beállítása
\usepackage{palatino}
\usepackage{courier}

%%% felsõ és alsó margó beállítása, elhagyható
\usepackage[top=3cm,bottom=2cm,inner=2.5cm,outer=2.5cm]{geometry}

% bekezdés behúzásának átállítása
\setlength{\parindent}{0pt} 

% matematikai képletek írásához
\usepackage{amsmath}   
\usepackage{amssymb}

% függvények kapcsolódási szerkezetének rajzolásához
\usepackage{tikz}
\usetikzlibrary{shapes}

% stuki rajzolásához be kell tölteni a .tex forrásfájllal azonos könyvtárba helyezett stuki.sty-t
\usepackage{stuki}

% programkód megjelenítéséhez
\usepackage{listings}
\lstset{language=C++, basicstyle=\ttfamily, keywordstyle=\color{blue}\ttfamily, stringstyle=\color{red}\ttfamily}

% specifikáció állapotterében \alatt{arg1}{arg2} saját paranccsal adható meg
% az arg1 típusértékhalmaz és a hozzá tartozó arg2 változó
\newcommand*{\alatt}[2]{\underset{\mathop{\vrule height 5pt width 0pt\relax #2}}{#1}}

% a specifikáció utófeltételében használt nagy függvények definiálása
\DeclareMathOperator*{\SEARCH}{\textit{\small \textbf{SEARCH}}}
\DeclareMathOperator*{\SELECT}{\textit{\small \textbf{SELECT}}}
\DeclareMathOperator*{\MAX}{\textit{\small \textbf{MAX}}}

%%% az adatokat tartalmazó doboz rajzolásához
\usepackage{tcolorbox}

% sorszámozott listához
\usepackage{enumitem}

% több oszlopos bekezdések
\usepackage{multicol}

\usepackage{graphicx}

\begin{document}

%%%%%%%%%%%%%%%%%%%% SZEMÉLYES ADATOK %%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{tcolorbox}[title=\Large{\textsc{Objektum elvû alkalmazások fejlesztése}}\\Dokumentáció a 2. házi feladathoz,arc=0mm]
\begin{minipage}[t]{0.5\textwidth}
	\textbf{Név:} Soós Bálint\\
	\textbf{Neptun kód:} HDX9MU\\
	\textbf{Elérhetõség:} soba95@inf.elte.hu
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}\raggedleft{
	\textbf{Csoport:} 8.\\
	\textbf{Feladatszám:} 7.\\
	\today}
\end{minipage}
\end{tcolorbox}
\end{center}
\vspace{18pt}

%%%%%%%%%%%%%%%%%%%% FELADAT LEÍRÁSA %%%%%%%%%%%%%%%%%%%%
{\textbf {Feladatleírás}}\\[6pt]
Készítsen egy halmaz típust! A halmazt rendezett láncolt listával ábrázolja!
Implementálja a szokásos mûveleteket (elem betétele, kivétele, benne van-e egy adott
elem, üres-e), egészítse ki az osztályt a halmaz tartalmát kiíró operátor<<-ral!
Definiáljon olyan barát-operátorokat is, amely kiszámítja két halmaz szimmetrikus
differenciáját és metszetét! A metszet mûveletigénye: O(m+n), ahol m és n a két
halmaz elemszáma. 

\vspace{18pt}

{\textbf {Halmaz típus}}\\[6pt]
A feladat megoldásához definiálni kell egy egész számokat tartalmazó halmaz típust. 

\vspace{18pt}

{\textbf {Típusérték-halmaz}}\\[6pt]
Egész számok halmaza. (beleértve az üres halmazt is)

\vspace{18pt}

{\textbf {Típus-mûveletek}}\\[1pt]
\begin{enumerate}[topsep=1pt,noitemsep,leftmargin=*]
	\item \textit{Elem berakása a halmazba}\\[4pt]
	A felhasználó által megadott egész számot berakjuk a halmaz elemei közé, így a halmaz mérete eggyel nõ. Érdemes megjegyezni, hogy a mûveletet csak akkor kell elvégezni, ha az adott elem még nem szerepel a halmazban.\\
	\item \textit{Elem kivétele a halmazból}\\[4pt]
	Elõször megvizsgáljuk, hogy szerepel-e az adott elem a halmazban. Ha igen, akkor az elemet eltávolítjuk a halmazból, így mérete eggyel csökken.\\
	\item \textit{Üres-e a halmaz}\\[4pt]
	Megvizsgáljuk, hogy a halmazban van-e elem, azaz a halmaz üres, ha mérete 0.\\
	\item \textit{Elem benne van-e a halmazban}\\[4pt]
	Szerepel-e az adott elem a halmaz elemei között.\\
	\item \textit{Halmaz kiírása}\\[4pt]
	Megjelenítjük a halmaz méretét, és az elemek listáját.\\
	\newpage
	\item \textit{Két halmaz metszete}\\[4pt]
	Két halmaz metszete egy olyan halmaz, melynek elemei mindkét halmaznak is elemei.\\
	\item \textit{Két halmaz szimmetrikus differenciája}\\[4pt]
	Két halmaz szimmetrikus differenciája a halmazok úniójának és metszetének különbsége.\\
\end{enumerate}

{\textbf {Reprezentáció}}\\[6pt]
Az egész számokat tartalmazó halmazt egy egyirányú, fejelemes, láncolt listával ábrázoltam. Az halmazmûveletek hatékonyságát szem elõtt tartva a lista elemei rendezve vannak. A rendezéshez a beszúró rendezés algoritmusát használtam.\\

{\textbf {Implementáció}}\\[2pt]
\begin{enumerate}[topsep=1pt,noitemsep,leftmargin=*]
	\item \textit{Elem berakása a halmazba (put)}\\[4pt]
	A listán végighaladva a beszúró algoritmust alkalmazva a keresett pozícióban létrehozok egy új elemet és az elõtte lévõ elem next-jét az új elemre állítom, az új elem nextjét pedig az utána következõ elemre.\\
	\item \textit{Elem kivétele a halmazból (remove)}\\[4pt]
	Egy elem kivételénél ugyanazt az algoritmust használom, mint az elem berakásánál, csak itt a megadott pozícióban kiveszem az elemet, az elõtte álló elem mutatóját a következõ elemre állítom, illetve az adott elemet törlöm.\\
	\item \textit{Üres-e a halmaz (isEmpty)}\\[4pt]
	Ha a lista fejelemét követõ elsõ elem nullpointer, akkor a halmaz üres.
	\begin{stuki}
		\stm{empty := false}
		\begin{IF}{1}{\stm{root->next = 0}}
			\stm{empty := true}
			\ELSE
			\stm{-}
		\end{IF}
		\stm{return: empty}
	\end{stuki}
	\item \textit{Elem benne van-e a halmazban (isContain)}\\[4pt]
	\begin{stuki}
		\stm{found := false}
		\stm{*p = root->next}
		\begin{WHILE}{3}{\stm{\neg(p = 0) \wedge \neg found}}
			\begin{IF}{1}{\stm{p->value = n}}
				\stm{found = true}
				\ELSE
				\stm{-}
			\end{IF}
			\stm{p = p->next}
		\end{WHILE}
		\stm{return: found}
	\end{stuki}
	\newpage
	\item \textit{Halmaz kiírása (print)}\\[4pt]
	Lista elemein végiglépdelve kiírjuk a kimenetre az elemek értékeit.\\
	\item \textit{Két halmaz metszete (intersection)}\\[4pt]
	Az A és B halmaz metszetét (felhasználva, hogy a listák rendezettek és lehetnek üresek is) úgy kapjuk meg, hogy
	a két listán párhumazosan lépdelve, amíg valamelyik el nem fogy:
	\begin{enumerate}[noitemsep,label=\arabic*)]
		\item {ha A halmaz eleme nagyobb, mint a B halmaz eleme, akkor B halmaz következõ elemére lépek}
		\item {ha A halmaz eleme kisebb, mint a B halmaz eleme, akkor A halmaz következõ elemére lépek}
		\item {ha A halmaz eleme egyenlõ B halmaz elemével, akkor metszetelemet találtam}
	\end{enumerate}
	\item \textit{Két halmaz szimmetrikus differenciája (symDef)}\\[4pt]
	Az A és B halmaz szimmetrikus differenciáját (felhasználva, hogy a listák rendezettek és lehetnek üresek is) úgy kapjuk meg, hogy
	a két listán párhumazosan lépdelve, amíg valamelyik el nem fogy:
	\begin{enumerate}[noitemsep,label=\arabic*)]
		\item {ha A halmaz eleme nagyobb, mint a B halmaz eleme, akkor B halmaz elemét kiírom, majd a következõ elemére lépek}
		\item {ha A halmaz eleme kisebb, mint a B halmaz eleme, akkor A halmaz elemét kiírom, majd a következõ elemére lépek}
		\item {ha A halmaz eleme egyenlõ B halmaz elemével, akkor metszetelemet találtam, mindkettõvel a következõ elemükre lépek}
	\end{enumerate}
	Ha elfogy valamelyik halmaz, akkor a másik halmazban lévõ maradék elemek a szimmetrikus differencia elemei, tehát azokat is kiírom.
	
\end{enumerate}

\vspace{18pt}
%%%%%%%%%%%%%%%%%%%% TESZTELÉSI TERV %%%%%%%%%%%%%%%%%%%%
{\textbf {Tesztelési terv:}}%\\[2pt]
\begin{enumerate}[topsep=2pt,noitemsep,label=\Roman*),leftmargin=*]
	\item A feladat specifikációjára épülõ (fekete doboz) tesztesetek:
	\begin{enumerate}[noitemsep,label=\arabic*)]
		\item {1,2,3 hosszúságú halmazok létrehozása a put metódussal}
		\item {1,2,3 hosszúságú halmazok esetén a remove metódus kipróbálása}
		\item {0 hosszúságú halmazok esetén a remove metódus hívása}
		\item {0,1,2 hosszúságú halmazok esetén az isEmpty és isContain metódus kipróbálása}
		\item {0,1,2 hosszúságú halmazok esetén az isEmpty és isContain metódus kipróbálása}
		\item {0,1,2 hosszúságú halmazok esetén a print metódus kipróbálása}
		\item {két azonos (nem 0) hosszúságú halmazok metszete}
		\item {két különbözõ (nem 0) hosszúságú halmazok metszete}
		\item {két különbözõ (az egyik 0) hosszúságú halmazok metszete}
		\item {két 0 hosszúságú halmazok metszete}
	\end{enumerate}
	\item A megoldó programra épülõ (fehér doboz) tesztesetek:
	\begin{enumerate}[noitemsep,label=\arabic*)]
		\item Halmazok létrehozása (max 10 db halmaz)
		\item Már meglévõ 10 db halmaz esetén új halmaz létrehozás (max 10 db halmaz lehet)
		\item Halmazok közti váltás, ha valid, illetve ha invalid halmaz számot adunk meg
		\item Új elem berakása a halmazba, ha az még nem létezik.
		\item Új elem berakása a halmazba, ha az már létezik.
		\item Elem törlése a halmazból, ha az létezik.
		\item Elem törlése a halmazból, ha az nem létezik.
	\end{enumerate}
\end{enumerate}
\vspace{18pt}
{\textbf {Osztály}}\\[2pt]
Az egész számokat tartalmazó halmaz típust egy Set nevû osztály segítségével valósítottam meg.
\begin{table}[h]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\cline{1-2} \cline{4-4}
		\multicolumn{2}{|l|}{\textbf{Set}} & \textbf{} & \textbf{Exceptions} \\ \cline{1-2} \cline{4-4} 
		\multicolumn{2}{|l|}{\begin{tabular}[c]{@{}l@{}}-Node : struct\\ -root : Node\end{tabular}} &  &  \\ \hline
		\multicolumn{2}{|l|}{\begin{tabular}[c]{@{}l@{}}+Set()\\+Set(int)\\ +Set(Set\&)\\ +operator=(Set\&) : Set\\ +operator+(Set\&) : Set\\+operator-(Set\&) : Set\\ +operator<<(Set\&) : Set\\ +put(int) : void \\ +remove(int) : void \\ +print() : void \\ +intersection(Set\&) : void \\ +symDef(Set\&) : void \\ +isContain(int) : bool \\ +isEmpty() : bool \\ +getSize() : int \\ +getItems() : int* \\\end{tabular}} & \multicolumn{1}{c|}{{\color[HTML]{000000} }} & \begin{tabular}[c]{@{}l@{}}+EMPTY\\ +CONTAIN\\ +INVALID\_ITEM\end{tabular} \\ \cline{1-2} \cline{4-4} 
	\end{tabular}
\end{table}

Az osztály-definíciót a set.h fejállományban helyeztem el.\\
\end{document}